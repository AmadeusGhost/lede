diff --git a/Makefile b/Makefile
index 715c03e..bfd51da 100644
--- a/Makefile
+++ b/Makefile
@@ -25,6 +25,11 @@ ifneq ($(filter madwifi,$(IWINFO_BACKENDS)),)
 	IWINFO_LIB_OBJ += iwinfo_madwifi.o
 endif
 
+ifneq ($(filter mtwifi,$(IWINFO_BACKENDS)),)
+	IWINFO_CFLAGS  += -DUSE_RTWIFI
+	IWINFO_LIB_OBJ += iwinfo_rtwifi.o
+endif
+
 ifneq ($(filter nl80211,$(IWINFO_BACKENDS)),)
 	IWINFO_CFLAGS      += -DUSE_NL80211
 	IWINFO_CLI_LDFLAGS += -lnl-tiny
diff --git a/api/ralink.h b/api/ralink.h
new file mode 100644
index 0000000..29f0951
--- /dev/null
+++ b/api/ralink.h
@@ -0,0 +1,325 @@
+/*
+ *
+ *  RT2860v2 802.11abg Networking Device Driver
+ *
+ *  Copyright (C) 2005-2013 lintel<lintel.huang@gmail.com>
+ *  Copyright (C) 2012-2013 luo<strugglelg@gmail.com>
+ *
+ *
+ */
+
+#ifndef _RALINK_H
+#define _RALINK_H
+
+#define WIF		"ra0"
+
+#define WIF_2G		"ra0"
+#define WIF_STA_2G	"apcli0"
+
+#define WIF_5G		"rai0"
+#define WIF_STA_5G	"apclii0"
+
+#define WIF_USB		"rausb0"
+#define WIF_STA_USB	"apcliusb0"
+
+#ifndef ETHER_ADDR_LEN
+#define ETHER_ADDR_LEN		6
+#endif
+
+#define MAX_NUMBER_OF_MAC	130
+
+#define MODE_CCK		0
+#define MODE_OFDM		1
+#define MODE_HTMIX		2
+#define MODE_HTGREENFIELD	3
+
+/*
+ * iwinfo宏定义
+ */
+
+#define MAC_ADDR_LEN		6
+#define ETH_LENGTH_OF_ADDRESS	6
+#define MAX_LEN_OF_MAC_TABLE	64
+
+#define RT_PRIV_IOCTL				(SIOCIWFIRSTPRIV + 0x01)
+#define RTPRIV_IOCTL_SET			(SIOCIWFIRSTPRIV + 0x02)
+
+#define RTPRIV_IOCTL_BBP			(SIOCIWFIRSTPRIV + 0x03)
+#define RTPRIV_IOCTL_MAC			(SIOCIWFIRSTPRIV + 0x05)
+#define RTPRIV_IOCTL_E2P			(SIOCIWFIRSTPRIV + 0x07)
+
+#define RTPRIV_IOCTL_STATISTICS			(SIOCIWFIRSTPRIV + 0x09)
+#define RTPRIV_IOCTL_ADD_PMKID_CACHE		(SIOCIWFIRSTPRIV + 0x0A)
+#define RTPRIV_IOCTL_RADIUS_DATA		(SIOCIWFIRSTPRIV + 0x0C)
+#define RTPRIV_IOCTL_GSITESURVEY		(SIOCIWFIRSTPRIV + 0x0D)
+#define RTPRIV_IOCTL_ADD_WPA_KEY		(SIOCIWFIRSTPRIV + 0x0E)
+#define RTPRIV_IOCTL_GET_MAC_TABLE		(SIOCIWFIRSTPRIV + 0x0F)
+#define RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT	(SIOCIWFIRSTPRIV + 0x1F)
+#define RTPRIV_IOCTL_STATIC_WEP_COPY		(SIOCIWFIRSTPRIV + 0x10)
+#define RTPRIV_IOCTL_WSC_PROFILE		(SIOCIWFIRSTPRIV + 0x12)
+#define	RTPRIV_IOCTL_GSTAINFO			(SIOCIWFIRSTPRIV + 0x1A)
+#define	RTPRIV_IOCTL_GSTAT			(SIOCIWFIRSTPRIV + 0x1B)
+#define RTPRIV_IOCTL_GRSSI			(SIOCIWFIRSTPRIV + 0x1C)
+#define RTPRIV_IOCTL_GTXBFCALP			(SIOCIWFIRSTPRIV + 0x1D)
+
+#define RT_QUERY_ATE_TXDONE_COUNT		0x0401
+#define OID_GET_SET_TOGGLE			0x8000
+
+#define OID_802_11_NETWORK_TYPES_SUPPORTED	0x0103
+#define OID_802_11_NETWORK_TYPE_IN_USE		0x0104
+#define OID_802_11_RSSI_TRIGGER			0x0107
+#define RT_OID_802_11_RSSI			0x0108  //rt2860 only , kathy
+#define RT_OID_802_11_RSSI_1			0x0109  //rt2860 only , kathy
+#define RT_OID_802_11_RSSI_2			0x010A  //rt2860 only , kathy
+#define OID_802_11_NUMBER_OF_ANTENNAS		0x010B
+#define OID_802_11_RX_ANTENNA_SELECTED		0x010C
+#define OID_802_11_TX_ANTENNA_SELECTED		0x010D
+#define OID_802_11_SUPPORTED_RATES		0x010E
+#define OID_802_11_ADD_WEP			0x0112
+#define OID_802_11_REMOVE_WEP			0x0113
+#define OID_802_11_DISASSOCIATE			0x0114
+#define OID_802_11_PRIVACY_FILTER		0x0118
+#define OID_802_11_ASSOCIATION_INFORMATION	0x011E
+#define OID_802_11_TEST				0x011F
+#define RT_OID_802_11_COUNTRY_REGION		0x0507
+#define OID_802_11_BSSID_LIST_SCAN		0x0508
+#define OID_802_11_SSID				0x0509
+#define OID_802_11_BSSID			0x050A
+#define RT_OID_802_11_RADIO			0x050B
+#define RT_OID_802_11_PHY_MODE			0x050C
+#define RT_OID_802_11_STA_CONFIG		0x050D
+#define OID_802_11_DESIRED_RATES		0x050E
+#define RT_OID_802_11_PREAMBLE			0x050F
+#define OID_802_11_WEP_STATUS			0x0510
+#define OID_802_11_AUTHENTICATION_MODE		0x0511
+#define OID_802_11_INFRASTRUCTURE_MODE		0x0512
+#define RT_OID_802_11_RESET_COUNTERS		0x0513
+#define OID_802_11_RTS_THRESHOLD		0x0514
+#define OID_802_11_FRAGMENTATION_THRESHOLD	0x0515
+#define OID_802_11_POWER_MODE			0x0516
+#define OID_802_11_TX_POWER_LEVEL		0x0517
+#define RT_OID_802_11_ADD_WPA			0x0518
+#define OID_802_11_REMOVE_KEY			0x0519
+#define OID_802_11_ADD_KEY			0x0520
+#define OID_802_11_CONFIGURATION		0x0521
+#define OID_802_11_TX_PACKET_BURST		0x0522
+#define RT_OID_802_11_QUERY_NOISE_LEVEL		0x0523
+#define RT_OID_802_11_EXTRA_INFO		0x0524
+#define RT_OID_802_11_HARDWARE_REGISTER		0x0525
+#define OID_802_11_ENCRYPTION_STATUS		OID_802_11_WEP_STATUS
+
+#define RT_OID_DEVICE_NAME			0x0607
+#define RT_OID_VERSION_INFO			0x0608
+#define OID_802_11_BSSID_LIST			0x0609
+#define OID_802_3_CURRENT_ADDRESS		0x060A
+#define OID_GEN_MEDIA_CONNECT_STATUS		0x060B
+#define RT_OID_802_11_QUERY_LINK_STATUS		0x060C
+#define OID_802_11_RSSI				0x060D
+#define OID_802_11_STATISTICS			0x060E
+#define OID_GEN_RCV_OK				0x060F
+#define OID_GEN_RCV_NO_BUFFER			0x0610
+#define RT_OID_802_11_QUERY_EEPROM_VERSION	0x0611
+#define RT_OID_802_11_QUERY_FIRMWARE_VERSION	0x0612
+#define RT_OID_802_11_QUERY_LAST_RX_RATE	0x0613
+#define RT_OID_802_11_TX_POWER_LEVEL_1		0x0614
+#define RT_OID_802_11_QUERY_PIDVID		0x0615
+
+//#if WPA_SUPPLICANT_SUPPORT
+#define OID_SET_COUNTERMEASURES			0x0616
+#define OID_802_11_SET_IEEE8021X		0x0617
+#define OID_802_11_SET_IEEE8021X_REQUIRE_KEY	0x0618
+#define OID_802_11_PMKID			0x0620
+#define RT_OID_WPA_SUPPLICANT_SUPPORT		0x0621
+#define RT_OID_WE_VERSION_COMPILED		0x0622
+//#endif
+
+//rt2860 , kathy
+#define	RT_OID_802_11_SNR_0			0x0630
+#define	RT_OID_802_11_SNR_1			0x0631
+#define	RT_OID_802_11_QUERY_LAST_TX_RATE	0x0632
+#define	RT_OID_802_11_QUERY_HT_PHYMODE		0x0633
+#define	RT_OID_802_11_SET_HT_PHYMODE		0x0634
+#define	OID_802_11_RELOAD_DEFAULTS		0x0635
+#define	RT_OID_802_11_QUERY_APSD_SETTING	0x0636
+#define	RT_OID_802_11_SET_APSD_SETTING		0x0637
+#define	RT_OID_802_11_QUERY_APSD_PSM		0x0638
+#define	RT_OID_802_11_SET_APSD_PSM		0x0639
+#define	RT_OID_802_11_QUERY_DLS			0x063A
+#define	RT_OID_802_11_SET_DLS			0x063B
+#define	RT_OID_802_11_QUERY_DLS_PARAM		0x063C
+#define	RT_OID_802_11_SET_DLS_PARAM		0x063D
+#define RT_OID_802_11_QUERY_WMM			0x063E
+#define RT_OID_802_11_SET_WMM			0x063F
+#define RT_OID_802_11_QUERY_IMME_BA_CAP		0x0640
+#define RT_OID_802_11_SET_IMME_BA_CAP		0x0641
+#define RT_OID_802_11_QUERY_BATABLE		0x0642
+#define RT_OID_802_11_ADD_IMME_BA		0x0643
+#define RT_OID_802_11_TEAR_IMME_BA		0x0644
+#define RT_OID_DRIVER_DEVICE_NAME		0x0645
+#define RT_OID_802_11_QUERY_DAT_HT_PHYMODE	0x0646
+#define RT_OID_QUERY_MULTIPLE_CARD_SUPPORT	0x0647
+#define OID_802_11_SET_PSPXLINK_MODE		0x0648
+#define OID_802_11_SET_PASSPHRASE		0x0649
+#define RT_OID_802_11_SNR_2			0x064a
+#define RT_OID_802_11_STREAM_SNR		0x064b
+#define RT_OID_802_11_QUERY_TXBF_TABLE		0x0650
+#define RT_OID_802_11_WSC_QUERY_PROFILE		0x0750
+#define RT_OID_WSC_UUID				0x0753
+
+#define RT_OID_GET_COUNTRYCODE			0x0998
+#define RT_OID_GET_ENCRYPTYPE			0x0999
+
+
+// mesh extension OID
+#define OID_802_11_MESH_LINK_STATUS		0x0654
+#define OID_802_11_MESH_LIST			0x0655
+
+
+// Ralink defined OIDs
+// Dennis Lee move to platform specific
+
+#define RT_OID_802_11_BSSID			(OID_GET_SET_TOGGLE | OID_802_11_BSSID)
+#define RT_OID_802_11_SSID			(OID_GET_SET_TOGGLE | OID_802_11_SSID)
+#define RT_OID_802_11_INFRASTRUCTURE_MODE	(OID_GET_SET_TOGGLE | OID_802_11_INFRASTRUCTURE_MODE)
+#define RT_OID_802_11_ADD_WEP			(OID_GET_SET_TOGGLE | OID_802_11_ADD_WEP)
+#define RT_OID_802_11_ADD_KEY			(OID_GET_SET_TOGGLE | OID_802_11_ADD_KEY)
+#define RT_OID_802_11_REMOVE_WEP		(OID_GET_SET_TOGGLE | OID_802_11_REMOVE_WEP)
+#define RT_OID_802_11_REMOVE_KEY		(OID_GET_SET_TOGGLE | OID_802_11_REMOVE_KEY)
+#define RT_OID_802_11_DISASSOCIATE		(OID_GET_SET_TOGGLE | OID_802_11_DISASSOCIATE)
+#define RT_OID_802_11_AUTHENTICATION_MODE	(OID_GET_SET_TOGGLE | OID_802_11_AUTHENTICATION_MODE)
+#define RT_OID_802_11_PRIVACY_FILTER		(OID_GET_SET_TOGGLE | OID_802_11_PRIVACY_FILTER)
+#define RT_OID_802_11_BSSID_LIST_SCAN		(OID_GET_SET_TOGGLE | OID_802_11_BSSID_LIST_SCAN)
+#define RT_OID_802_11_WEP_STATUS		(OID_GET_SET_TOGGLE | OID_802_11_WEP_STATUS)
+#define RT_OID_802_11_RELOAD_DEFAULTS		(OID_GET_SET_TOGGLE | OID_802_11_RELOAD_DEFAULTS)
+#define RT_OID_802_11_NETWORK_TYPE_IN_USE	(OID_GET_SET_TOGGLE | OID_802_11_NETWORK_TYPE_IN_USE)
+#define RT_OID_802_11_TX_POWER_LEVEL		(OID_GET_SET_TOGGLE | OID_802_11_TX_POWER_LEVEL)
+#define RT_OID_802_11_RSSI_TRIGGER		(OID_GET_SET_TOGGLE | OID_802_11_RSSI_TRIGGER)
+#define RT_OID_802_11_FRAGMENTATION_THRESHOLD	(OID_GET_SET_TOGGLE | OID_802_11_FRAGMENTATION_THRESHOLD)
+#define RT_OID_802_11_RTS_THRESHOLD		(OID_GET_SET_TOGGLE | OID_802_11_RTS_THRESHOLD)
+#define RT_OID_802_11_RX_ANTENNA_SELECTED	(OID_GET_SET_TOGGLE | OID_802_11_RX_ANTENNA_SELECTED)
+#define RT_OID_802_11_TX_ANTENNA_SELECTED	(OID_GET_SET_TOGGLE | OID_802_11_TX_ANTENNA_SELECTED)
+#define RT_OID_802_11_SUPPORTED_RATES		(OID_GET_SET_TOGGLE | OID_802_11_SUPPORTED_RATES)
+#define RT_OID_802_11_DESIRED_RATES		(OID_GET_SET_TOGGLE | OID_802_11_DESIRED_RATES)
+#define RT_OID_802_11_CONFIGURATION		(OID_GET_SET_TOGGLE | OID_802_11_CONFIGURATION)
+#define RT_OID_802_11_POWER_MODE		(OID_GET_SET_TOGGLE | OID_802_11_POWER_MODE)
+
+
+/* for WPS --YY  */
+#define RT_OID_SYNC_RT61			0x0D010750
+#define RT_OID_WSC_QUERY_STATUS			((RT_OID_SYNC_RT61 + 0x01) & 0xffff)
+#define RT_OID_WSC_PIN_CODE			((RT_OID_SYNC_RT61 + 0x02) & 0xffff)
+
+
+#define OFFSET_COUNTRY_CODE	0x40188
+#define OFFSET_MAC_ADDR		0x40004
+#define OFFSET_MAC_GMAC2	0x40022
+#define OFFSET_MAC_GMAC0	0x40028
+#define OFFSET_PIN_CODE		0x40180
+#define OFFSET_TXBF_PARA	0x401A0
+#define OFFSET_MAC_ADDR_5G	0x48004
+
+
+enum NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeWPA2,
+	Ndis802_11AuthModeWPA2PSK,
+	Ndis802_11AuthModeWPA1WPA2,
+	Ndis802_11AuthModeWPA1PSKWPA2PSK,
+#ifdef WAPI_SUPPORT
+	Ndis802_11AuthModeWAICERT,	/* WAI certificate authentication */
+	Ndis802_11AuthModeWAIPSK,	/* WAI pre-shared key */
+#endif				/* WAPI_SUPPORT */
+	Ndis802_11AuthModeMax	/* Not a real mode, defined as upper bound */
+};
+
+enum NDIS_802_11_WEP_STATUS {
+	Ndis802_11WEPEnabled,
+	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+	Ndis802_11WEPDisabled,
+	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+	Ndis802_11WEPKeyAbsent,
+	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+	Ndis802_11WEPNotSupported,
+	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+	Ndis802_11Encryption2Enabled,
+	Ndis802_11Encryption2KeyAbsent,
+	Ndis802_11Encryption3Enabled,
+	Ndis802_11Encryption3KeyAbsent,
+	Ndis802_11Encryption4Enabled,	/* TKIP or AES mix */
+	Ndis802_11Encryption4KeyAbsent,
+	Ndis802_11GroupWEP40Enabled,
+	Ndis802_11GroupWEP104Enabled,
+#ifdef WAPI_SUPPORT
+	Ndis802_11EncryptionSMS4Enabled,	/* WPI SMS4 support */
+#endif /* WAPI_SUPPORT */
+};
+
+
+typedef struct _COUNTER_HOTSPOT {
+    // ULONG           LinkUpTime;
+    unsigned long      LastDataPacketTime;
+    unsigned long      TotalTxByteCount;
+    unsigned long      TotalRxByteCount;
+} COUNTER_HOTSPOT, *PCOUNTER_HOTSPOT;
+
+
+#define MODE_CCK		0
+#define MODE_OFDM		1
+#define MODE_HTMIX		2
+#define MODE_HTGREENFIELD	3
+#define MODE_VHT		4
+
+#define BW_20			0
+#define BW_40			1
+#define BW_80			2
+#define BW_BOTH			3
+#define BW_10			4 // not used
+
+typedef union _MACHTTRANSMIT_SETTING {
+	struct {
+		unsigned short MCS:6;
+		unsigned short ldpc:1;
+		unsigned short BW:2;
+		unsigned short ShortGI:1;
+		unsigned short STBC:1;
+		unsigned short eTxBF:1;
+		unsigned short iTxBF:1;
+		unsigned short MODE:3;
+	} field;
+	unsigned short word;
+} MACHTTRANSMIT_SETTING, *PMACHTTRANSMIT_SETTING;
+
+//#define CONFIG_RT2860V2_AP_V24_DATA_STRUCTURE 1
+//#define CONFIG_RT2860V2_AP_TXBF 		1
+
+typedef struct _RT_802_11_MAC_ENTRY {
+	unsigned char	ApIdx;
+	unsigned char	Addr[ETHER_ADDR_LEN];
+	unsigned char	Aid;
+	unsigned char	Psm;     // 0:PWR_ACTIVE, 1:PWR_SAVE
+	unsigned char	MimoPs;  // 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled
+	char		AvgRssi0;
+	char		AvgRssi1;
+	char		AvgRssi2;
+	unsigned int	ConnectedTime;
+	MACHTTRANSMIT_SETTING	TxRate;
+	unsigned int	LastRxRate;
+	unsigned long 	TxPackets;  //TxPackets.QuadPart
+	unsigned long 	RxPackets;  //RxPackets.QuadPart
+	unsigned long 	TxBytes;
+	unsigned long 	RxBytes;
+	unsigned long 	LastTxOkCount;  /* TxSuccess count in last Rate Adaptation interval */
+	char 		LastTxPER;      /* Tx PER in last Rate Adaptation interval */
+} RT_802_11_MAC_ENTRY;
+
+typedef struct _RT_802_11_MAC_TABLE {
+	unsigned long            Num;
+	RT_802_11_MAC_ENTRY      Entry[MAX_NUMBER_OF_MAC];  //MAX_LEN_OF_MAC_TABLE = 130
+} RT_802_11_MAC_TABLE;
+
+#endif
diff --git a/hardware.txt b/hardware.txt
index 262c69e..bc8f5bb 100644
--- a/hardware.txt
+++ b/hardware.txt
@@ -160,6 +160,7 @@
 0x168c 0x003c 0x168c 0x3223    0      0  "Qualcomm Atheros" "QCA9880"
 0x168c 0x003c 0x1a56 0x1420    0      0  "Qualcomm Atheros" "QCA9862"
 0x168c 0x003c 0x19b6 0xd03c    0      0  "Mikrotik" "R11e-5HacT"
+0x168c 0x003c 0x19b6 0xd075    0      0  "Mikrotik" "R11e-5HacD"
 0x168c 0x0040 0x168c 0x0002    0      0  "Qualcomm Atheros" "QCA9990"
 0x168c 0x0046 0x168c 0xcafe    0      0  "Qualcomm Atheros" "QCA9984"
 0x168c 0x0050 0x0000 0x0000    0      0  "Qualcomm Atheros" "QCA9887"
diff --git a/include/iwinfo.h b/include/iwinfo.h
index 5e64294..b4ddb95 100644
--- a/include/iwinfo.h
+++ b/include/iwinfo.h
@@ -99,7 +99,11 @@ extern const char *IWINFO_HTMODE_NAMES[IWINFO_HTMODE_COUNT];
 struct iwinfo_rate_entry {
 	uint32_t rate;
 	int8_t mcs;
+#ifdef USE_RTWIFI
+	uint8_t is_40mhz:2;
+#else
 	uint8_t is_40mhz:1;
+#endif
 	uint8_t is_short_gi:1;
 	uint8_t is_ht:1;
 	uint8_t is_vht:1;
@@ -258,6 +262,7 @@ void iwinfo_finish(void);
 extern const struct iwinfo_ops wext_ops;
 extern const struct iwinfo_ops madwifi_ops;
 extern const struct iwinfo_ops nl80211_ops;
+extern const struct iwinfo_ops rtwifi_ops;
 extern const struct iwinfo_ops wl_ops;
 
 #include "iwinfo/utils.h"
diff --git a/include/iwinfo/lua.h b/include/iwinfo/lua.h
index 8b76b25..0ebd5c5 100644
--- a/include/iwinfo/lua.h
+++ b/include/iwinfo/lua.h
@@ -37,6 +37,10 @@
 #define IWINFO_MADWIFI_META	"iwinfo.madwifi"
 #endif
 
+#ifdef USE_RTWIFI
+#define IWINFO_RTWIFI_META	"iwinfo.rtwifi"
+#endif
+
 #ifdef USE_NL80211
 #define IWINFO_NL80211_META	"iwinfo.nl80211"
 #endif
diff --git a/iwinfo_lib.c b/iwinfo_lib.c
index 7a33a35..1b8f43a 100644
--- a/iwinfo_lib.c
+++ b/iwinfo_lib.c
@@ -331,6 +331,9 @@ static const struct iwinfo_ops *backends[] = {
 #ifdef USE_MADWIFI
 	&madwifi_ops,
 #endif
+#ifdef USE_RTWIFI
+	&rtwifi_ops,
+#endif
 #ifdef USE_WL
 	&wl_ops,
 #endif
diff --git a/iwinfo_lua.c b/iwinfo_lua.c
index 58a5537..0afc0e8 100644
--- a/iwinfo_lua.c
+++ b/iwinfo_lua.c
@@ -720,6 +720,36 @@ LUA_WRAP_STRUCT_OP(madwifi,mbssid_support)
 LUA_WRAP_STRUCT_OP(madwifi,hardware_id)
 #endif
 
+#ifdef USE_RTWIFI
+/* Ralink */
+LUA_WRAP_INT_OP(rtwifi,channel)
+LUA_WRAP_INT_OP(rtwifi,frequency)
+LUA_WRAP_INT_OP(rtwifi,frequency_offset)
+LUA_WRAP_INT_OP(rtwifi,txpower)
+LUA_WRAP_INT_OP(rtwifi,txpower_offset)
+LUA_WRAP_INT_OP(rtwifi,bitrate)
+LUA_WRAP_INT_OP(rtwifi,signal)
+LUA_WRAP_INT_OP(rtwifi,noise)
+LUA_WRAP_INT_OP(rtwifi,quality)
+LUA_WRAP_INT_OP(rtwifi,quality_max)
+LUA_WRAP_STRING_OP(rtwifi,ssid)
+LUA_WRAP_STRING_OP(rtwifi,bssid)
+LUA_WRAP_STRING_OP(rtwifi,country)
+LUA_WRAP_STRING_OP(rtwifi,hardware_name)
+LUA_WRAP_STRING_OP(rtwifi,phyname)
+LUA_WRAP_STRUCT_OP(rtwifi,mode)
+LUA_WRAP_STRUCT_OP(rtwifi,assoclist)
+LUA_WRAP_STRUCT_OP(rtwifi,txpwrlist)
+LUA_WRAP_STRUCT_OP(rtwifi,scanlist)
+LUA_WRAP_STRUCT_OP(rtwifi,freqlist)
+LUA_WRAP_STRUCT_OP(rtwifi,countrylist)
+LUA_WRAP_STRUCT_OP(rtwifi,hwmodelist)
+LUA_WRAP_STRUCT_OP(rtwifi,htmodelist)
+LUA_WRAP_STRUCT_OP(rtwifi,encryption)
+LUA_WRAP_STRUCT_OP(rtwifi,mbssid_support)
+LUA_WRAP_STRUCT_OP(rtwifi,hardware_id)
+#endif
+
 #ifdef USE_NL80211
 /* NL80211 */
 LUA_WRAP_INT_OP(nl80211,channel)
@@ -844,6 +874,39 @@ static const luaL_reg R_madwifi[] = {
 };
 #endif
 
+#ifdef USE_RTWIFI
+/* Ralink table */
+static const luaL_reg R_rtwifi[] = {
+	LUA_REG(rtwifi,channel),
+	LUA_REG(rtwifi,frequency),
+	LUA_REG(rtwifi,frequency_offset),
+	LUA_REG(rtwifi,txpower),
+	LUA_REG(rtwifi,txpower_offset),
+	LUA_REG(rtwifi,bitrate),
+	LUA_REG(rtwifi,signal),
+	LUA_REG(rtwifi,noise),
+	LUA_REG(rtwifi,quality),
+	LUA_REG(rtwifi,quality_max),
+	LUA_REG(rtwifi,mode),
+	LUA_REG(rtwifi,ssid),
+	LUA_REG(rtwifi,bssid),
+	LUA_REG(rtwifi,country),
+	LUA_REG(rtwifi,assoclist),
+	LUA_REG(rtwifi,txpwrlist),
+	LUA_REG(rtwifi,scanlist),
+	LUA_REG(rtwifi,freqlist),
+	LUA_REG(rtwifi,countrylist),
+	LUA_REG(rtwifi,hwmodelist),
+	LUA_REG(rtwifi,htmodelist),
+	LUA_REG(rtwifi,encryption),
+	LUA_REG(rtwifi,mbssid_support),
+	LUA_REG(rtwifi,hardware_id),
+	LUA_REG(rtwifi,hardware_name),
+	LUA_REG(rtwifi,phyname),
+	{ NULL, NULL }
+};
+#endif
+
 #ifdef USE_NL80211
 /* NL80211 table */
 static const luaL_reg R_nl80211[] = {
@@ -937,6 +1000,15 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 	lua_setfield(L, -2, "madwifi");
 #endif
 
+#ifdef USE_RTWIFI
+	luaL_newmetatable(L, IWINFO_RTWIFI_META);
+	luaL_register(L, NULL, R_common);
+	luaL_register(L, NULL, R_rtwifi);
+	lua_pushvalue(L, -1);
+	lua_setfield(L, -2, "__index");
+	lua_setfield(L, -2, "rtwifi");
+#endif
+
 #ifdef USE_NL80211
 	luaL_newmetatable(L, IWINFO_NL80211_META);
 	luaL_register(L, NULL, R_common);
diff --git a/iwinfo_rtwifi.c b/iwinfo_rtwifi.c
new file mode 100644
index 0000000..359278d
--- /dev/null
+++ b/iwinfo_rtwifi.c
@@ -0,0 +1,1195 @@
+/*
+ *  iwinfo - Wireless Information Library - Ralink/MTK RT2860v2
+ *
+ *  Copyright (C) 2005-2013 lintel<lintel.huang@gmail.com>
+ *  Copyright (C) 2012-2013 luo<strugglelg@gmail.com>
+ *  Copyright (C) 2012-2013 bywayboy<bywayboy@gmail.com>
+ *  Copyright (c) 2020, jjm2473 <jjm2473@gmail.com>
+ */
+
+#include "iwinfo.h"
+#include "iwinfo_wext.h"
+#include "iwinfo/utils.h"
+#include "api/ralink.h"
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/sockios.h>
+#include <arpa/inet.h>
+
+/*
+ * Ralink ISO 3166 to Country/Region Code mapping.
+ */
+
+static struct ISO3166_to_CCode
+{
+	u_int16_t iso3166;
+	u_int16_t ccode;
+}
+
+CountryCodes[] =
+{
+	{ 0x3030 /* 00 */,   0 }, /* World */
+	{ 0x4145 /* AE */, 784 }, /* U.A.E. */
+	{ 0x414C /* AL */,   8 }, /* Albania */
+	{ 0x414D /* AM */,  51 }, /* Armenia */
+	{ 0x4152 /* AR */,  32 }, /* Argentina */
+	{ 0x4154 /* AT */,  40 }, /* Austria */
+	{ 0x4155 /* AU */,  36 }, /* Australia */
+	{ 0x415A /* AZ */,  31 }, /* Azerbaijan */
+	{ 0x4245 /* BE */,  56 }, /* Belgium */
+	{ 0x4247 /* BG */, 100 }, /* Bulgaria */
+	{ 0x4248 /* BH */,  48 }, /* Bahrain */
+	{ 0x424E /* BN */,  96 }, /* Brunei Darussalam */
+	{ 0x424F /* BO */,  68 }, /* Bolivia */
+	{ 0x4252 /* BR */,  76 }, /* Brazil */
+	{ 0x4259 /* BY */, 112 }, /* Belarus */
+	{ 0x425A /* BZ */,  84 }, /* Belize */
+	{ 0x4341 /* CA */, 124 }, /* Canada */
+	{ 0x4348 /* CH */, 756 }, /* Switzerland */
+	{ 0x434C /* CL */, 152 }, /* Chile */
+	{ 0x434E /* CN */, 156 }, /* People's Republic of China */
+	{ 0x434F /* CO */, 170 }, /* Colombia */
+	{ 0x4352 /* CR */, 188 }, /* Costa Rica */
+	{ 0x4359 /* CY */, 196 }, /* Cyprus */
+	{ 0x435A /* CZ */, 203 }, /* Czech Republic */
+	{ 0x4445 /* DE */, 276 }, /* Germany */
+	{ 0x444B /* DK */, 208 }, /* Denmark */
+	{ 0x444F /* DO */, 214 }, /* Dominican Republic */
+	{ 0x445A /* DZ */,  12 }, /* Algeria */
+	{ 0x4543 /* EC */, 218 }, /* Ecuador */
+	{ 0x4545 /* EE */, 233 }, /* Estonia */
+	{ 0x4547 /* EG */, 818 }, /* Egypt */
+	{ 0x4553 /* ES */, 724 }, /* Spain */
+	{ 0x4649 /* FI */, 246 }, /* Finland */
+	{ 0x464F /* FO */, 234 }, /* Faeroe Islands */
+	{ 0x4652 /* FR */, 250 }, /* France */
+	{ 0x4652 /* FR */, 255 }, /* France2 */
+	{ 0x4742 /* GB */, 826 }, /* United Kingdom */
+	{ 0x4745 /* GE */, 268 }, /* Georgia */
+	{ 0x4752 /* GR */, 300 }, /* Greece */
+	{ 0x4754 /* GT */, 320 }, /* Guatemala */
+	{ 0x484B /* HK */, 344 }, /* Hong Kong S.A.R., P.R.C. */
+	{ 0x484E /* HN */, 340 }, /* Honduras */
+	{ 0x4852 /* HR */, 191 }, /* Croatia */
+	{ 0x4855 /* HU */, 348 }, /* Hungary */
+	{ 0x4944 /* ID */, 360 }, /* Indonesia */
+	{ 0x4945 /* IE */, 372 }, /* Ireland */
+	{ 0x494C /* IL */, 376 }, /* Israel */
+	{ 0x494E /* IN */, 356 }, /* India */
+	{ 0x4951 /* IQ */, 368 }, /* Iraq */
+	{ 0x4952 /* IR */, 364 }, /* Iran */
+	{ 0x4953 /* IS */, 352 }, /* Iceland */
+	{ 0x4954 /* IT */, 380 }, /* Italy */
+	{ 0x4A4D /* JM */, 388 }, /* Jamaica */
+	{ 0x4A4F /* JO */, 400 }, /* Jordan */
+	{ 0x4A50 /* JP */, 392 }, /* Japan */
+	{ 0x4A50 /* JP */, 393 }, /* Japan (JP1) */
+	{ 0x4A50 /* JP */, 394 }, /* Japan (JP0) */
+	{ 0x4A50 /* JP */, 395 }, /* Japan (JP1-1) */
+	{ 0x4A50 /* JP */, 396 }, /* Japan (JE1) */
+	{ 0x4A50 /* JP */, 397 }, /* Japan (JE2) */
+	{ 0x4A50 /* JP */, 399 }, /* Japan (JP6) */
+	{ 0x4A50 /* JP */, 900 }, /* Japan */
+	{ 0x4A50 /* JP */, 901 }, /* Japan */
+	{ 0x4A50 /* JP */, 902 }, /* Japan */
+	{ 0x4A50 /* JP */, 903 }, /* Japan */
+	{ 0x4A50 /* JP */, 904 }, /* Japan */
+	{ 0x4A50 /* JP */, 905 }, /* Japan */
+	{ 0x4A50 /* JP */, 906 }, /* Japan */
+	{ 0x4A50 /* JP */, 907 }, /* Japan */
+	{ 0x4A50 /* JP */, 908 }, /* Japan */
+	{ 0x4A50 /* JP */, 909 }, /* Japan */
+	{ 0x4A50 /* JP */, 910 }, /* Japan */
+	{ 0x4A50 /* JP */, 911 }, /* Japan */
+	{ 0x4A50 /* JP */, 912 }, /* Japan */
+	{ 0x4A50 /* JP */, 913 }, /* Japan */
+	{ 0x4A50 /* JP */, 914 }, /* Japan */
+	{ 0x4A50 /* JP */, 915 }, /* Japan */
+	{ 0x4A50 /* JP */, 916 }, /* Japan */
+	{ 0x4A50 /* JP */, 917 }, /* Japan */
+	{ 0x4A50 /* JP */, 918 }, /* Japan */
+	{ 0x4A50 /* JP */, 919 }, /* Japan */
+	{ 0x4A50 /* JP */, 920 }, /* Japan */
+	{ 0x4A50 /* JP */, 921 }, /* Japan */
+	{ 0x4A50 /* JP */, 922 }, /* Japan */
+	{ 0x4A50 /* JP */, 923 }, /* Japan */
+	{ 0x4A50 /* JP */, 924 }, /* Japan */
+	{ 0x4A50 /* JP */, 925 }, /* Japan */
+	{ 0x4A50 /* JP */, 926 }, /* Japan */
+	{ 0x4A50 /* JP */, 927 }, /* Japan */
+	{ 0x4A50 /* JP */, 928 }, /* Japan */
+	{ 0x4A50 /* JP */, 929 }, /* Japan */
+	{ 0x4A50 /* JP */, 930 }, /* Japan */
+	{ 0x4A50 /* JP */, 931 }, /* Japan */
+	{ 0x4A50 /* JP */, 932 }, /* Japan */
+	{ 0x4A50 /* JP */, 933 }, /* Japan */
+	{ 0x4A50 /* JP */, 934 }, /* Japan */
+	{ 0x4A50 /* JP */, 935 }, /* Japan */
+	{ 0x4A50 /* JP */, 936 }, /* Japan */
+	{ 0x4A50 /* JP */, 937 }, /* Japan */
+	{ 0x4A50 /* JP */, 938 }, /* Japan */
+	{ 0x4A50 /* JP */, 939 }, /* Japan */
+	{ 0x4A50 /* JP */, 940 }, /* Japan */
+	{ 0x4A50 /* JP */, 941 }, /* Japan */
+	{ 0x4B45 /* KE */, 404 }, /* Kenya */
+	{ 0x4B50 /* KP */, 408 }, /* North Korea */
+	{ 0x4B52 /* KR */, 410 }, /* South Korea */
+	{ 0x4B52 /* KR */, 411 }, /* South Korea */
+	{ 0x4B57 /* KW */, 414 }, /* Kuwait */
+	{ 0x4B5A /* KZ */, 398 }, /* Kazakhstan */
+	{ 0x4C42 /* LB */, 422 }, /* Lebanon */
+	{ 0x4C49 /* LI */, 438 }, /* Liechtenstein */
+	{ 0x4C54 /* LT */, 440 }, /* Lithuania */
+	{ 0x4C55 /* LU */, 442 }, /* Luxembourg */
+	{ 0x4C56 /* LV */, 428 }, /* Latvia */
+	{ 0x4C59 /* LY */, 434 }, /* Libya */
+	{ 0x4D41 /* MA */, 504 }, /* Morocco */
+	{ 0x4D43 /* MC */, 492 }, /* Principality of Monaco */
+	{ 0x4D4B /* MK */, 807 }, /* the Former Yugoslav Republic of Macedonia */
+	{ 0x4D4F /* MO */, 446 }, /* Macau */
+	{ 0x4D58 /* MX */, 484 }, /* Mexico */
+	{ 0x4D59 /* MY */, 458 }, /* Malaysia */
+	{ 0x4E49 /* NI */, 558 }, /* Nicaragua */
+	{ 0x4E4C /* NL */, 528 }, /* Netherlands */
+	{ 0x4E4F /* NO */, 578 }, /* Norway */
+	{ 0x4E5A /* NZ */, 554 }, /* New Zealand */
+	{ 0x4F4D /* OM */, 512 }, /* Oman */
+	{ 0x5041 /* PA */, 591 }, /* Panama */
+	{ 0x5045 /* PE */, 604 }, /* Peru */
+	{ 0x5048 /* PH */, 608 }, /* Republic of the Philippines */
+	{ 0x504B /* PK */, 586 }, /* Islamic Republic of Pakistan */
+	{ 0x504C /* PL */, 616 }, /* Poland */
+	{ 0x5052 /* PR */, 630 }, /* Puerto Rico */
+	{ 0x5054 /* PT */, 620 }, /* Portugal */
+	{ 0x5059 /* PY */, 600 }, /* Paraguay */
+	{ 0x5141 /* QA */, 634 }, /* Qatar */
+	{ 0x524F /* RO */, 642 }, /* Romania */
+	{ 0x5255 /* RU */, 643 }, /* Russia */
+	{ 0x5341 /* SA */, 682 }, /* Saudi Arabia */
+	{ 0x5345 /* SE */, 752 }, /* Sweden */
+	{ 0x5347 /* SG */, 702 }, /* Singapore */
+	{ 0x5349 /* SI */, 705 }, /* Slovenia */
+	{ 0x534B /* SK */, 703 }, /* Slovak Republic */
+	{ 0x5356 /* SV */, 222 }, /* El Salvador */
+	{ 0x5359 /* SY */, 760 }, /* Syria */
+	{ 0x5448 /* TH */, 764 }, /* Thailand */
+	{ 0x544E /* TN */, 788 }, /* Tunisia */
+	{ 0x5452 /* TR */, 792 }, /* Turkey */
+	{ 0x5454 /* TT */, 780 }, /* Trinidad y Tobago */
+	{ 0x5457 /* TW */, 158 }, /* Taiwan */
+	{ 0x5541 /* UA */, 804 }, /* Ukraine */
+	{ 0x554B /* UK */, 826 }, /* United Kingdom */
+	{ 0x5553 /* US */, 840 }, /* United States */
+	{ 0x5553 /* US */, 842 }, /* United States (Public Safety)*/
+	{ 0x5559 /* UY */, 858 }, /* Uruguay */
+	{ 0x555A /* UZ */, 860 }, /* Uzbekistan */
+	{ 0x5645 /* VE */, 862 }, /* Venezuela */
+	{ 0x564E /* VN */, 704 }, /* Viet Nam */
+	{ 0x5945 /* YE */, 887 }, /* Yemen */
+	{ 0x5A41 /* ZA */, 710 }, /* South Africa */
+	{ 0x5A57 /* ZW */, 716 }, /* Zimbabwe */
+};
+
+static int ra_ioctl(const char *ifname, int cmd, struct iwreq *wrq)
+{
+	if( !strncmp(ifname, "mon.", 4) )
+		strncpy(wrq->ifr_name, &ifname[4], IFNAMSIZ);
+	else
+		strncpy(wrq->ifr_name, ifname, IFNAMSIZ);
+
+	return iwinfo_ioctl(cmd, wrq);
+}
+
+int ra_oid_ioctl(const char *ifname,unsigned long oid, char *ptr, unsigned long ptr_len)
+{
+	struct iwreq wrq;
+	int cmd = RT_PRIV_IOCTL;
+	strcpy(wrq.ifr_name, ifname);
+	wrq.u.data.length = ptr_len;
+	wrq.u.data.pointer =  ptr;
+	wrq.u.data.flags = oid;
+
+	return iwinfo_ioctl(RT_PRIV_IOCTL, &wrq);
+}
+
+int iwpriv_set(const char *name, const char *key, const char *val)
+{
+	int socket_id, ret = 0;
+	struct iwreq wrq;
+	char data[64];
+	snprintf(data, 64, "%s=%s", key, val);
+	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
+
+	wrq.u.data.length = strlen(data);
+	wrq.u.data.pointer = data;
+	wrq.u.data.flags = 0;
+	ret=ra_ioctl(name, RTPRIV_IOCTL_SET, &wrq);
+	close(socket_id);
+	return ret;
+}
+
+int rtwifi_probe(const char *ifname)
+{
+	unsigned char data[12];
+	int version;
+	if(strncmp(ifname,"ra",2) == 0 || strncmp(ifname,"wds",3) == 0 || strncmp(ifname,"apcli",5) == 0)
+		return 1;
+
+	return 0;
+}
+
+void rtwifi_close(void)
+{
+	iwinfo_close();
+}
+
+static int rtwifi_get_phyname(const char *ifname, char *buf)
+{
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		strcpy(buf, ifname);
+	if((strncmp(ifname,"rai",3) == 0) ||
+		(strncmp(ifname,"wdsi",4) == 0) ||
+		(strncmp(ifname,"apclii",6) == 0))
+		strcpy(buf, "rai");
+	else if((strncmp(ifname,"rax",3) == 0) ||
+		(strncmp(ifname,"wdsx",4) == 0) ||
+		(strncmp(ifname,"apclix",6) == 0))
+		strcpy(buf, "rax");
+	else
+		strcpy(buf, "ra");
+
+	return 0;
+}
+
+int rtwifi_get_mode(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if(strncmp(ifname,"ra",2) == 0)
+		*buf = IWINFO_OPMODE_MASTER;
+	else if (strncmp(ifname,"apcli",5) == 0)
+		*buf = IWINFO_OPMODE_CLIENT;
+	else if (strncmp(ifname,"wds",3) == 0)
+		*buf = IWINFO_OPMODE_WDS;
+	else
+		*buf = IWINFO_OPMODE_UNKNOWN;
+
+	return 0;
+}
+
+int rtwifi_get_ssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	wrq.u.essid.pointer = (caddr_t) buf;
+	wrq.u.essid.length  = IW_ESSID_MAX_SIZE + 1;
+	wrq.u.essid.flags   = 0;
+
+	if(ra_ioctl(ifname, SIOCGIWESSID, &wrq) >= 0)
+		return 0;
+
+	return -1;
+}
+
+int rtwifi_get_bssid(const char *ifname, char *buf)
+{
+	struct iwreq wrq;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	if(ra_ioctl(ifname, SIOCGIWAP, &wrq) >= 0)
+	{
+		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
+			(uint8_t)wrq.u.ap_addr.sa_data[0], (uint8_t)wrq.u.ap_addr.sa_data[1],
+			(uint8_t)wrq.u.ap_addr.sa_data[2], (uint8_t)wrq.u.ap_addr.sa_data[3],
+			(uint8_t)wrq.u.ap_addr.sa_data[4], (uint8_t)wrq.u.ap_addr.sa_data[5]);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int32_t ra_freq2mhz(const struct iw_freq *in)
+{
+	int i;
+	int32_t res = in->m;
+
+	if (in->e == 6) {
+		return res;
+	} else if (in->e > 6) {
+		for (i=in->e; i>6; --i) {
+			res *= 10;
+		}
+	} else {
+		for (i=in->e; i<6; ++i) {
+			res /= 10;
+		}
+	}
+
+	return res;
+}
+
+int rtwifi_get_channel(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+    if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+        return -1;
+
+	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		*buf = wrq.u.freq.i;
+		return 0;
+	}
+
+	return -1;
+}
+
+int rtwifi_get_frequency(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
+	{
+		*buf = ra_freq2mhz(&wrq.u.freq);
+		return 0;
+	}
+
+	return -1;
+}
+
+int rtwifi_get_txpower(const char *ifname, int *buf)
+{
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	return wext_ops.txpower(ifname, buf);
+}
+
+int rtwifi_get_bitrate(const char *ifname, int *buf)
+{
+	struct iwreq wrq;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	if(ra_ioctl(ifname, SIOCGIWRATE, &wrq) >= 0)
+	{
+		*buf = (wrq.u.bitrate.value / 1000);
+		return 0;
+	}
+
+	return -1;
+}
+
+int rtwifi_get_signal(const char *ifname, int *buf)
+{
+	int ret;
+	unsigned long ra_snr;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	ret = ra_oid_ioctl(ifname, RT_OID_802_11_SNR_1, &ra_snr, sizeof(ra_snr) );
+	if (ra_oid_ioctl(ifname, RT_OID_802_11_SNR_0, &ra_snr, sizeof(ra_snr)) >= 0)
+	{
+		*buf = 0 - (50 - ra_snr);
+		return 0;
+	}
+	else
+		return -1;
+}
+
+int rtwifi_get_noise(const char *ifname, int *buf)
+{
+	int ret;
+	unsigned long ra_snr = 0;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	ret = ra_oid_ioctl(ifname, RT_OID_802_11_SNR_0, &ra_snr, sizeof(ra_snr) );
+	if (ret  >= 0)
+	{
+		*buf = 0 - (100 - ra_snr);
+		return 0;
+	}
+	else
+		return -1;
+}
+
+int rtwifi_get_quality(const char *ifname, int *buf)
+{
+	int ret;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	ret = wext_ops.signal(ifname,buf);
+	*buf += 130;
+	if(*buf >= 100)
+		*buf = 100;
+	return ret;
+}
+
+int rtwifi_get_quality_max(const char *ifname, int *buf)
+{
+	*buf = 100;
+	return 0;
+}
+
+int rtwifi_get_encryption(const char *ifname, char *buf)
+{
+	int i;
+	FILE *fp;
+	char filename[64] = {0};
+	long filesize;
+	char buffer[256] = {0};
+	char enc[20] = "NONE";
+	char file_flag[]="#Encryption";
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0))
+		return -1;
+
+	uint32_t wsec, wauth, wpa;
+	struct iwinfo_crypto_entry *c = (struct iwinfo_crypto_entry *)buf;
+
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+
+	memset(filename, 0, sizeof(filename));
+	sprintf(filename, "/tmp/wifi_encryption_%s.dat", ifname);
+	fp = fopen(filename, "r");
+	if(fp == NULL)
+	{
+		printf("open ifname:%s failed.\n", ifname);
+		return -1;
+	}
+
+	if (fseek(fp, 0, SEEK_END) == 0)
+		filesize = ftell(fp);
+
+	if (fseek(fp, 0, SEEK_SET) == 0)
+	{
+		fgets(buffer, filesize, fp);
+	}
+
+	if(strncmp(buffer, file_flag, strlen(file_flag)) != 0)
+	{
+		return -1;
+	}
+
+	memset(buffer, 0, sizeof(buffer));
+	fgets(buffer, filesize, fp);
+	if(strstr(buffer, "WPA") )
+	{
+		memset(buffer, 0, sizeof(buffer));
+		fgets(buffer, filesize, fp);
+
+		if(strstr(buffer, "WPAPSKWPA2PSK") )
+		{
+			c->wpa_version = 3;
+			c->auth_suites |= IWINFO_KMGMT_PSK;
+		}
+		else if(strstr(buffer, "WPAPSK") )
+		{
+			c->wpa_version = 1;
+			c->auth_suites |= IWINFO_KMGMT_PSK;
+		}
+		else if(strstr(buffer, "WPA2PSK") )
+		{
+			c->wpa_version = 2;
+			c->auth_suites |= IWINFO_KMGMT_PSK;
+		}
+        else
+            return -1;
+
+		memset(buffer, 0, sizeof(buffer));
+		fgets(buffer, filesize, fp);
+
+		if(strstr(buffer, "TKIPAES"))
+		{
+			c->pair_ciphers |= IWINFO_CIPHER_TKIP;
+			c->pair_ciphers |= IWINFO_CIPHER_CCMP;
+		}
+		else if(strstr(buffer, "AES"))
+			c->pair_ciphers |= IWINFO_CIPHER_CCMP;
+		else if(strstr(buffer, "TKIP"))
+			c->pair_ciphers |= IWINFO_CIPHER_TKIP;
+    }
+	else if(strstr(buffer, "WEP") )
+	{
+		c->auth_algs |= IWINFO_AUTH_SHARED;
+		c->pair_ciphers = IWINFO_CIPHER_WEP40 | IWINFO_CIPHER_WEP104;
+		c->auth_suites |= IWINFO_KMGMT_NONE;
+	}
+	else if(strstr(buffer, "NONE") )
+	{
+		sprintf(buf, "NONE");
+	}
+	else
+	{
+		sprintf(buf, "Unknown");
+		return -1;
+	}
+
+	c->enabled = (c->wpa_version || c->auth_algs) ? 1 : 0;
+	c->group_ciphers = c->pair_ciphers;
+
+	fclose(fp);
+	return 0;
+}
+
+int MCSMappingRateTable[] =
+{
+	2,  4,   11,  22,								// CCK
+
+	12,  18,  24,  36,  48,  72,  96, 108,						// OFDM
+
+	13,  26,  39,  52,  78, 104, 117, 130, 26,  52,  78, 104, 156, 208, 234, 260,	// 11n: 20MHz, 800ns GI, MCS: 0 ~ 15
+	39,  78, 117, 156, 234, 312, 351, 390,						// 11n: 20MHz, 800ns GI, MCS: 16 ~ 23
+	27,  54,  81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,	// 11n: 40MHz, 800ns GI, MCS: 0 ~ 15
+	81, 162, 243, 324, 486, 648, 729, 810,						// 11n: 40MHz, 800ns GI, MCS: 16 ~ 23
+	14,  29,  43,  57,  87, 115, 130, 144, 29, 59,   87, 115, 173, 230, 260, 288,	// 11n: 20MHz, 400ns GI, MCS: 0 ~ 15
+	43,  87, 130, 173, 260, 317, 390, 433,						// 11n: 20MHz, 400ns GI, MCS: 16 ~ 23
+	30,  60,  90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,	// 11n: 40MHz, 400ns GI, MCS: 0 ~ 15
+	90, 180, 270, 360, 540, 720, 810, 900,
+
+	13,  26,  39,  52,  78, 104, 117, 130, 156,					// 11ac: 20Mhz, 800ns GI, MCS: 0~8
+	27,  54,  81, 108, 162, 216, 243, 270, 324, 360,				// 11ac: 40Mhz, 800ns GI, MCS: 0~9
+	59, 117, 176, 234, 351, 468, 527, 585, 702, 780,				// 11ac: 80Mhz, 800ns GI, MCS: 0~9
+	14,  29,  43,  57,  87, 115, 130, 144, 173,					// 11ac: 20Mhz, 400ns GI, MCS: 0~8
+	30,  60,  90, 120, 180, 240, 270, 300, 360, 400,				// 11ac: 40Mhz, 400ns GI, MCS: 0~9
+	65, 130, 195, 260, 390, 520, 585, 650, 780, 867					// 11ac: 80Mhz, 400ns GI, MCS: 0~9
+};
+
+int get_rate(MACHTTRANSMIT_SETTING TxRate)
+{
+	int rate_count = sizeof(MCSMappingRateTable)/sizeof(int);
+	int rate_index = 0;
+	int num_ss_vht = 1;
+
+	if (TxRate.field.MODE >= MODE_VHT)
+	{
+		int mcs_1ss = (int)TxRate.field.MCS;
+
+		if (mcs_1ss > 9)
+		{
+			num_ss_vht = (mcs_1ss / 16) + 1;
+			mcs_1ss %= 16;
+		}
+		if (TxRate.field.BW == BW_20)
+			rate_index = 108 + ((unsigned char)TxRate.field.ShortGI * 29) + mcs_1ss;
+		else if (TxRate.field.BW == BW_40)
+			rate_index = 117 + ((unsigned char)TxRate.field.ShortGI * 29) + mcs_1ss;
+		else if (TxRate.field.BW == BW_80)
+			rate_index = 127 + ((unsigned char)TxRate.field.ShortGI * 29) + mcs_1ss;
+	}
+	else if (TxRate.field.MODE >= MODE_HTMIX)
+		rate_index = 12 + ((unsigned char)TxRate.field.BW * 24) + ((unsigned char)TxRate.field.ShortGI * 48) + ((unsigned char)TxRate.field.MCS);
+	else if (TxRate.field.MODE == MODE_OFDM)
+		rate_index = (unsigned char)(TxRate.field.MCS) + 4;
+	else if (TxRate.field.MODE == MODE_CCK)
+		rate_index = (unsigned char)(TxRate.field.MCS);
+
+	if (rate_index < 0)
+		rate_index = 0;
+
+	if (rate_index >= rate_count)
+		rate_index = rate_count-1;
+
+	return (MCSMappingRateTable[rate_index] * num_ss_vht * 5)/10;
+}
+
+int ra_parse_rate(struct iwinfo_rate_entry *iwrate,MACHTTRANSMIT_SETTING *rarate)
+{
+	if(rarate->field.BW == BW_20 ) {
+		iwrate->mhz=20;
+	iwrate->is_ht=1;
+	} else if (rarate->field.BW == BW_40 ) {
+		iwrate->mhz=40;
+		iwrate->is_ht=1;
+	} else if ((rarate->field.BW == BW_80 ) || (rarate->field.BW == BW_BOTH )) {
+		iwrate->mhz=80;
+		iwrate->is_vht=1;
+	}
+	iwrate->is_40mhz = (iwrate->mhz == 40);
+	iwrate->is_short_gi = rarate->field.ShortGI;
+	iwrate->mcs = rarate->field.MCS;
+	iwrate->rate = get_rate(*rarate) * 1000;
+	iwrate->nss = 2;
+}
+
+int rtwifi_get_assoclist(const char *ifname, char *buf, int *len)
+{
+	int  ret,i;
+	int bl = 0, tl, noise;
+	struct iwreq wrq;
+	struct iwinfo_assoclist_entry entry;
+	char tmpBuff[64];
+	char mac_addr[5][20];
+	char *phyMode[4] = {"CCK", "OFDM", "MM", "GF"};
+	unsigned int mcs;
+	RT_802_11_MAC_TABLE table = {0};
+	MACHTTRANSMIT_SETTING RxRate;
+
+	if((strcmp(ifname,"ra") == 0) || (strcmp(ifname,"rai") == 0) || (strcmp(ifname,"rax") == 0) || (strncmp(ifname,"wds", 3) == 0))
+		return -1;
+
+	if (ra_oid_ioctl(ifname,RT_OID_VERSION_INFO,tmpBuff, sizeof(tmpBuff)) < 0)
+		return -1;
+
+	if(!strcmp(ifname,"apcli0") || !strcmp(ifname,"apclii0") || !strcmp(ifname,"apclix0") || !strcmp(ifname,"apcliusb0"))
+		return -1;
+
+	int ifapid=0;
+	int noisenum=0;
+
+	if(strncmp(ifname,"rai",3)==0)
+	{
+		rtwifi_get_noise("rai0",&noisenum);
+		ifapid=atoi(ifname+3);
+	}
+	else if(strncmp(ifname,"rax",3)==0)
+	{
+		rtwifi_get_noise("rax0",&noisenum);
+		ifapid=atoi(ifname+3)+4; //WARNING:This depends on script BssidNum settings.
+	}
+	else if(strncmp(ifname,"rausb",5)==0)
+	{
+		rtwifi_get_noise("rausb0",&noisenum);
+		ifapid=atoi(ifname+5);
+	}
+	else if(strncmp(ifname,"ra",2)==0)
+	{
+		rtwifi_get_noise("ra0",&noisenum);
+		ifapid=atoi(ifname+2);
+	}
+
+	if(!noisenum)
+		noisenum=-90;
+
+	wrq.u.data.pointer = (caddr_t)&table;
+	wrq.u.data.length = sizeof(table);
+	wrq.u.data.flags = 0;
+	ret = ra_ioctl(ifname, RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT, &wrq);
+	if (ret < 0)
+	{
+		printf("assoclist ioctl fails\n");
+		return -1;
+	}
+
+	for (i = 0; i < table.Num; i++)
+	{
+		RT_802_11_MAC_ENTRY *pe = &(table.Entry[i]);
+
+		if( pe->ApIdx != ifapid )
+			continue;
+
+		memset(&entry, 0, sizeof(entry));
+
+		entry.signal = ((int)(pe->AvgRssi0) + (int)(pe->AvgRssi1))/2;
+
+		entry.noise  = noisenum;
+
+		entry.inactive  = pe->ConnectedTime * 1000;
+
+		memcpy(&entry.mac, &pe->Addr, sizeof(entry.mac));
+
+		entry.tx_packets = pe->TxPackets;
+		entry.rx_packets = pe->RxPackets;
+		entry.rx_bytes = pe->RxBytes;
+		entry.tx_bytes = pe->TxBytes;
+		entry.tx_retries = pe->LastTxOkCount;
+
+		RxRate.word = pe->LastRxRate;
+		RxRate.field.BW = ((pe->LastRxRate>>7) & 0x1);
+		RxRate.field.MCS = pe->LastRxRate & 0x7F;
+		RxRate.field.ShortGI = ((pe->LastRxRate>>8) & 0x1);
+		RxRate.field.MODE = MODE_HTMIX;
+
+		ra_parse_rate(&(entry.tx_rate),&(pe->TxRate));
+		ra_parse_rate(&(entry.rx_rate),&(RxRate));
+
+		memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
+
+		bl += sizeof(struct iwinfo_assoclist_entry);
+	}
+
+	*len = bl;
+	return 0;
+}
+
+int rtwifi_get_txpwrlist(const char *ifname, char *buf, int *len)
+{
+	struct iwinfo_txpwrlist_entry entry;
+
+	if (strcmp(ifname,"ra") == 0) return rtwifi_get_txpwrlist("ra0", buf, len);
+	else if (strcmp(ifname,"rai") == 0) return rtwifi_get_txpwrlist("rai0", buf, len);
+	else if (strcmp(ifname,"rax") == 0) return rtwifi_get_txpwrlist("rax0", buf, len);
+
+	uint8_t dbm[11] = { 0, 6, 8, 10, 12, 14, 16, 18, 20};
+	uint8_t mw[11]  = { 1, 3, 6, 10, 15, 25, 39, 63, 100};
+	int i;
+
+	for (i = 0; i < 11; i++)
+	{
+		entry.dbm = dbm[i];
+		entry.mw  = mw[i];
+		memcpy(&buf[i*sizeof(entry)], &entry, sizeof(entry));
+	}
+
+	*len = 11 * sizeof(entry);
+	return 0;
+}
+
+static void bssid2mac(char *macStr, unsigned char *mac)
+{
+	int i;
+	unsigned int iMac[6];
+	sscanf(macStr, "%x:%x:%x:%x:%x:%x", &iMac[0], &iMac[1], &iMac[2], &iMac[3], &iMac[4], &iMac[5]);
+	for (i = 0; i < 6; i++)
+		mac[i] = (unsigned char)iMac[i];
+}
+
+static void parse_security(char *sec, struct iwinfo_crypto_entry *enc)
+{
+	memset(enc, 0, sizeof(struct iwinfo_crypto_entry));
+	enc->enabled = 0;
+
+	if (strstr(sec, "WPA"))
+	{
+		enc->enabled = 1;
+		if (strstr(sec, "WPA1PSKWPA2PSK"))
+			enc->wpa_version = 3;
+		else if (strstr(sec, "WPA2PSK"))
+			enc->wpa_version = 2;
+		else if (strstr(sec, "WPAPSK"))
+			enc->wpa_version = 1;
+		else if (strstr(sec, "WPA"))
+			enc->wpa_version = 1;
+
+		enc->auth_suites |= IWINFO_KMGMT_PSK;
+
+		if (strstr(sec, "AES"))
+			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
+		else
+			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
+
+		enc->group_ciphers = enc->pair_ciphers;
+	}
+	else if (strstr(sec, "WEP"))
+	{
+		enc->enabled = 1;
+		enc->auth_algs |= IWINFO_AUTH_OPEN;
+		enc->pair_ciphers |= IWINFO_CIPHER_WEP104;
+		enc->auth_suites |= IWINFO_KMGMT_NONE;
+		enc->group_ciphers = enc->pair_ciphers;
+	}
+}
+
+int rtrim(char *s)
+{
+	int i;
+	i = strlen(s) - 1;
+	while ((s[i] == ' ' || s[i] == '\t') && i >= 0)
+	{
+		i--;
+	};
+	s[i + 1] = '\0';
+	return i + 1;
+}
+
+static void fill_find_entry(char *sp, struct iwinfo_scanlist_entry *e)
+{
+	char site_channel[4];
+	char site_ssid[33];
+	char site_bssid[20];
+	char site_security[23];
+	char site_signal[9];
+	char site_wirelessmode[7];
+	char ssid_str[128];
+	int len;
+
+	sp += 4; // skip No
+	memcpy(site_channel, sp, 4);
+	memcpy(site_ssid, sp + 4, 33);
+	memcpy(site_bssid, sp + 37, 20);
+	memcpy(site_security, sp + 57, 23);
+	memcpy(site_signal, sp + 80, 9);
+
+	rtrim(site_bssid);
+	rtrim(site_channel);
+	rtrim(site_security);
+	rtrim(site_signal);
+
+	e->channel = atoi(site_channel);
+	bssid2mac((unsigned char *)site_bssid, (unsigned char *)e->mac);
+	e->mode = IWINFO_OPMODE_MASTER;
+	parse_security((char *)site_security, &e->crypto);
+
+	int quality = atoi(site_signal);
+	int8_t rssi;
+	rssi = (quality * 95 / 100) - 95;
+
+	if (quality < 5)
+	{
+		rssi = -95;
+	}
+
+	e->signal = rssi;
+	e->quality = quality;
+	e->quality_max = 100;
+
+	len = rtrim(site_ssid);
+	if (!strlen(site_ssid))
+	{
+		strcpy(site_ssid, "???");
+		len = 3;
+	}
+	memcpy(e->ssid, site_ssid, len);
+}
+
+static char *next_line(char *sp) {
+	while (*sp != '\n' && *sp != '\0')
+		++sp;
+	if (*sp == '\n')
+		++sp; // skip \n
+	return sp;
+}
+
+int ra_get_scanlist(const char *ifname, char *buf, int *len)
+{
+	struct iwreq wrq;
+	char data[8192];
+	char *sp, *empty, *end;
+
+	int i, line_len;
+
+	iwpriv_set(ifname, "SiteSurvey", "1");
+	sleep(3);
+
+	memset(data, 0, sizeof(data));
+	wrq.u.data.length = sizeof(data);
+	wrq.u.data.pointer = data;
+	wrq.u.data.flags = 0;
+
+	if (ra_ioctl(ifname, RTPRIV_IOCTL_GSITESURVEY, &wrq) >= 0)
+	{
+		struct iwinfo_scanlist_entry e;
+		line_len = 4 + 4 + 33 + 20 + 23 + 9 + 8 + 7 + 3 + 9;
+		if (wrq.u.data.length < 1)
+			return -1;
+		sp = wrq.u.data.pointer + line_len + 2; // skip \n+\n
+		for (i = 0; i < 3; ++i) {
+			// skip \n+'Total=xxxx'+\n+HEADER+\n
+			sp = next_line(sp);
+		}
+		end = sp + strlen(sp);
+		i = 0;
+		while (*sp && ((len_a - (sp - op)) >= 0))
+		{
+			memset(&e, 0, sizeof(struct iwinfo_scanlist_entry));
+
+			fill_find_entry(sp, &e);
+
+			memcpy(&buf[i * sizeof(struct iwinfo_scanlist_entry)], &e, sizeof(struct iwinfo_scanlist_entry));
+
+			sp += line_len;
+			sp = next_line(sp);
+		}
+		*len = i * sizeof(struct iwinfo_scanlist_entry);
+		return 0;
+	}
+
+	return -1;
+}
+
+#define RA_MAX_CH_2G 13
+
+static const uint8_t CH5G[]={
+	/* 802.11 UNI / HyperLan 2 */
+	36, 40, 44, 48, 52, 56, 60, 64, //8
+	/* 802.11 HyperLan 2 */
+	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, //10
+	/* 802.11 UNII */
+	140, 144, 149, 153, 157, 161, 165
+};
+
+int rtwifi_get_freqlist(const char *ifname, char *buf, int *len)
+{
+	struct iwinfo_freqlist_entry entry;
+	int i, bl;
+	bl = 0;
+
+	if(!strcmp(ifname,"rai0"))
+	{
+		for(i = 0; i < RA_MAX_CH_2G; i++)
+		{
+			entry.mhz        = 2412 + 5 * i;
+			entry.channel    = i + 1;
+			entry.restricted = 0;
+
+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
+			bl += sizeof(struct iwinfo_freqlist_entry);
+		}
+	}
+	else
+	{
+		for(i = 0; i < ARRAY_SIZE(CH5G); i++)
+		{
+			entry.mhz        = 5000 + 5 * CH5G[i];
+			entry.channel    = CH5G[i];
+			entry.restricted = 0;
+
+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
+			bl += sizeof(struct iwinfo_freqlist_entry);
+		}
+	}
+
+	*len = bl;
+	return 0;
+}
+
+int rtwifi_get_country(const char *ifname, char *buf)
+{
+	char data[10];
+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
+		return -1;
+
+	if (ra_oid_ioctl(ifname, RT_OID_GET_COUNTRYCODE, buf, sizeof(buf)) < 0)
+		return -1;
+
+	return 0;
+}
+
+int rtwifi_get_countrylist(const char *ifname, char *buf, int *len)
+{
+
+	int i, count;
+	struct ISO3166_to_CCode *e, *p = NULL;
+	struct iwinfo_country_entry *c = (struct iwinfo_country_entry *)buf;
+	char data[10];
+	if (ra_oid_ioctl(ifname,RT_OID_VERSION_INFO,data, sizeof(data)) < 0)
+		return -1;
+	count = 0;
+
+	for(i = 0; i < (sizeof(CountryCodes)/sizeof(CountryCodes[0])); i++)
+	{
+		e = &CountryCodes[i];
+
+		if( !p || (e->iso3166 != p->iso3166) )
+		{
+			c->iso3166 = e->iso3166;
+			snprintf(c->ccode, sizeof(c->ccode), "%i", e->ccode);
+			c++;
+			count++;
+		}
+		p = e;
+	}
+
+	*len = (count * sizeof(struct iwinfo_country_entry));
+	return 0;
+}
+
+int rtwifi_get_hwmodelist(const char *ifname, int *buf)
+{
+	char data[10];
+	if((!strncmp(ifname,"rai", 3))||(!strncmp(ifname,"rax", 3))||(!strncmp(ifname,"wdsi", 4))||(!strncmp(ifname,"apclii", 6))||(!strncmp(ifname,"apclix", 6)))
+	{
+		*buf |= IWINFO_80211_A;
+		*buf |= IWINFO_80211_N;
+		*buf |= IWINFO_80211_AC;
+	}
+	else
+	{
+		*buf |= IWINFO_80211_B;
+		*buf |= IWINFO_80211_G;
+		*buf |= IWINFO_80211_N;
+	}
+
+	return 0;
+}
+
+int rtwifi_get_hardware_id(const char *ifname, char *buf);
+static int rtwifi_get_htmodelist(const char *ifname, int *buf)
+{
+	int modes;
+	struct iwinfo_hardware_id id;
+
+	if (!rtwifi_get_hwmodelist(ifname, &modes))
+	{
+		*buf = 0;
+
+		if (modes & IWINFO_80211_N)
+			*buf |= IWINFO_HTMODE_HT20 | IWINFO_HTMODE_HT40;
+
+		if (modes & IWINFO_80211_AC)
+			*buf |= IWINFO_HTMODE_VHT20 | IWINFO_HTMODE_VHT40 |
+					IWINFO_HTMODE_VHT80;
+
+		if (!rtwifi_get_hardware_id(ifname, (char *)&id))
+		{
+			if ((modes & IWINFO_80211_AC) && (id.vendor_id == 0x1814) && (id.device_id == 0x7615))
+				*buf |= IWINFO_HTMODE_VHT160;
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+int rtwifi_get_mbssid_support(const char *ifname, int *buf)
+{
+	char data[10];
+	if (ra_oid_ioctl(ifname,RT_OID_VERSION_INFO,data, sizeof(data)) < 0)
+		return -1;
+}
+
+int rtwifi_get_hwid_mtd(struct iwinfo_hardware_id *id, int start)
+{
+	FILE *mtd;
+	uint16_t *bc;
+
+	int fd, len, off;
+	char buf[128];
+
+	if (!(mtd = fopen("/proc/mtd", "r")))
+		return -1;
+
+	while (fgets(buf, sizeof(buf), mtd) > 0)
+	{
+		if (fscanf(mtd, "mtd%d: %x %*x %127s", &off, &len, buf) < 3 ||
+				(strcmp(buf, "\"factory\"")))
+		{
+			off = -1;
+			continue;
+		}
+		break;
+	}
+
+	fclose(mtd);
+
+	if (off < 0)
+		return -1;
+
+	snprintf(buf, sizeof(buf), "/dev/mtdblock%d", off);
+
+	if ((fd = open(buf, O_RDONLY)) < 0)
+		return -1;
+
+	bc = mmap(NULL, len, PROT_READ, MAP_PRIVATE|MAP_LOCKED, fd, 0);
+
+	if ((void *)bc != MAP_FAILED)
+	{
+		id->device_id = 0;
+		id->vendor_id = 0x1814;
+		id->subsystem_vendor_id = 0x1814;
+		id->device_id = bc[start];
+		id->subsystem_device_id = (bc[start + 0x1a] & 0x0f00) >> 8;
+		munmap(bc, len);
+	}
+
+	close(fd);
+
+	return (id->vendor_id && id->device_id) ? 0 : -1;
+}
+
+int rtwifi_get_hardware_id(const char *ifname, char *buf)
+{
+	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
+	memset(id, 0, sizeof(struct iwinfo_hardware_id));
+	char data[10];
+	if (ra_oid_ioctl(ifname,RT_OID_VERSION_INFO,data, sizeof(data)) < 0)
+		return -1;
+	id->vendor_id = 0x1814;
+	id->device_id = 0x2860;
+	id->subsystem_device_id = 0x1814;
+	id->subsystem_vendor_id = 0x0;
+	if(strncmp(ifname, "rausb", 5))
+		return (rtwifi_get_hwid_mtd(id, (strncmp(ifname,"rai",3) == 0)?0x4000:0));
+	else
+		return (id->vendor_id > 0 && id->device_id > 0) ? 0 : -1;
+}
+
+static const struct iwinfo_hardware_entry *
+rtwifi_get_hardware_entry(const char *ifname)
+{
+	struct iwinfo_hardware_id id;
+
+	if (rtwifi_get_hardware_id(ifname, (char *)&id))
+		return NULL;
+
+	return iwinfo_hardware(&id);
+}
+
+int rtwifi_get_hardware_name(const char *ifname, char *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+	char data[10];
+
+	if (ra_oid_ioctl(ifname,RT_OID_VERSION_INFO,data, sizeof(data)) < 0)
+		return -1;
+
+	if (!(hw = rtwifi_get_hardware_entry(ifname)))
+		sprintf(buf, "Generic Ralink/MTK Wireless");
+	else
+		sprintf(buf, "%s %s", hw->vendor_name, hw->device_name);
+	return 0;
+}
+
+int rtwifi_get_txpower_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
+
+int rtwifi_get_frequency_offset(const char *ifname, int *buf)
+{
+	return wext_ops.frequency(ifname,buf);
+}
+
+const struct iwinfo_ops rtwifi_ops =
+{
+	.name             = "rtwifi",
+	.probe         	  = rtwifi_probe,
+	.channel          = rtwifi_get_channel,
+	.frequency        = rtwifi_get_frequency,
+	.frequency_offset = rtwifi_get_frequency_offset,
+	.txpower          = rtwifi_get_txpower,
+	.txpower_offset   = rtwifi_get_txpower_offset,
+	.bitrate          = rtwifi_get_bitrate,
+	.signal           = rtwifi_get_signal,
+	.noise            = rtwifi_get_noise,
+	.quality          = rtwifi_get_quality,
+	.quality_max      = rtwifi_get_quality_max,
+	.mbssid_support   = rtwifi_get_mbssid_support,
+	.hwmodelist       = rtwifi_get_hwmodelist,
+	.htmodelist       = rtwifi_get_htmodelist,
+	.mode             = rtwifi_get_mode,
+	.ssid             = rtwifi_get_ssid,
+	.bssid            = rtwifi_get_bssid,
+	.country          = rtwifi_get_country,
+	.phyname          = rtwifi_get_phyname,
+	.hardware_id      = rtwifi_get_hardware_id,
+	.hardware_name    = rtwifi_get_hardware_name,
+	.encryption       = rtwifi_get_encryption,
+	.assoclist        = rtwifi_get_assoclist,
+	.txpwrlist        = rtwifi_get_txpwrlist,
+	.scanlist         = rtwifi_get_scanlist,
+	.freqlist         = rtwifi_get_freqlist,
+	.countrylist      = rtwifi_get_countrylist,
+	.close            = rtwifi_close
+};
