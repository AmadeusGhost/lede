From 72c39970039fa46ad95cf304e8f75c73b2627092 Mon Sep 17 00:00:00 2001
From: Robert Marko <robert.marko@sartura.hr>
Date: Tue, 3 Mar 2020 20:19:31 +0100
Subject: [PATCH] ipq40xx: 5.4: fix ethernet driver

In 5.4 kernel old u32 array way of setting network features was dropped and
linkmode is now the only way. So lets migrate the EDMA driver to support
linkmode. Also, old get/set settings API for ethtool is also dropped so lets
convert to new ksettings API while at it as it demands linkmode.

Signed-off-by: Robert Marko <robert.marko@sartura.hr>
---
 .../ethernet/qualcomm/essedma/edma_ethtool.c  | 65 ++++++++++---------
 1 file changed, 36 insertions(+), 29 deletions(-)

diff --git a/edma_ethtool.c b/edma_ethtool.c
index 8f6e3833b6e7..1270e20a90cc 100644
--- a/edma_ethtool.c
+++ b/edma_ethtool.c
@@ -239,7 +239,7 @@ static uint32_t edma_get_msglevel(struct net_device *netdev)
  *	Get edma settings
  */
 static int edma_get_settings(struct net_device *netdev,
-			     struct ethtool_cmd *ecmd)
+			     struct ethtool_link_ksettings *cmd)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
 
@@ -253,14 +253,14 @@ static int edma_get_settings(struct net_device *netdev,
 		 */
 		if (adapter->forced_speed != SPEED_UNKNOWN) {
 			/* set speed and duplex */
-			ethtool_cmd_speed_set(ecmd, SPEED_1000);
-			ecmd->duplex = DUPLEX_FULL;
+			cmd->base.speed = SPEED_1000;
+			cmd->base.duplex = DUPLEX_FULL;
 
 			/* Populate capabilities advertised by self */
-			ecmd->advertising = 0;
-			ecmd->autoneg = 0;
-			ecmd->port = PORT_TP;
-			ecmd->transceiver = XCVR_EXTERNAL;
+			linkmode_zero(cmd->link_modes.advertising);
+			cmd->base.autoneg = 0;
+			cmd->base.port = PORT_TP;
+			cmd->base.transceiver = XCVR_EXTERNAL;
 		} else {
 			/* non link polled and non
 			 * forced speed/duplex interface
@@ -280,38 +280,46 @@ static int edma_get_settings(struct net_device *netdev,
 
 		phydev = adapter->phydev;
 
-		ecmd->advertising = phydev->advertising;
-		ecmd->autoneg = phydev->autoneg;
+		linkmode_copy(cmd->link_modes.advertising, phydev->advertising);
+		linkmode_copy(cmd->link_modes.supported, phydev->supported);
+
+		cmd->base.autoneg = phydev->autoneg;
 
 		if (adapter->link_state == __EDMA_LINKDOWN) {
-			ecmd->speed =  SPEED_UNKNOWN;
-			ecmd->duplex = DUPLEX_UNKNOWN;
+			cmd->base.speed =  SPEED_UNKNOWN;
+			cmd->base.duplex = DUPLEX_UNKNOWN;
 		} else {
-			ecmd->speed = phydev->speed;
-			ecmd->duplex = phydev->duplex;
+			cmd->base.speed = phydev->speed;
+			cmd->base.duplex = phydev->duplex;
 		}
 
-		ecmd->phy_address = adapter->phy_mdio_addr;
+		cmd->base.phy_address = adapter->phy_mdio_addr;
 
 		phyreg = (uint16_t)phy_read(adapter->phydev, MII_LPA);
 		if (phyreg & LPA_10HALF)
-			ecmd->lp_advertising |= ADVERTISED_10baseT_Half;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+								cmd->link_modes.lp_advertising);
 
 		if (phyreg & LPA_10FULL)
-			ecmd->lp_advertising |= ADVERTISED_10baseT_Full;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+								cmd->link_modes.lp_advertising);
 
 		if (phyreg & LPA_100HALF)
-			ecmd->lp_advertising |= ADVERTISED_100baseT_Half;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+								cmd->link_modes.lp_advertising);
 
 		if (phyreg & LPA_100FULL)
-			ecmd->lp_advertising |= ADVERTISED_100baseT_Full;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+								cmd->link_modes.lp_advertising);
 
 		phyreg = (uint16_t)phy_read(adapter->phydev, MII_STAT1000);
 		if (phyreg & LPA_1000HALF)
-			ecmd->lp_advertising |= ADVERTISED_1000baseT_Half;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+								cmd->link_modes.lp_advertising);
 
 		if (phyreg & LPA_1000FULL)
-			ecmd->lp_advertising |= ADVERTISED_1000baseT_Full;
+			linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+								cmd->link_modes.lp_advertising);
 	}
 	mutex_unlock(&adapter->poll_mutex);
 
@@ -322,7 +330,7 @@ static int edma_get_settings(struct net_device *netdev,
  *	Set EDMA settings
  */
 static int edma_set_settings(struct net_device *netdev,
-			     struct ethtool_cmd *ecmd)
+			     const struct ethtool_link_ksettings *cmd)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
 	struct phy_device *phydev = NULL;
@@ -335,10 +343,11 @@ static int edma_set_settings(struct net_device *netdev,
 	}
 
 	phydev = adapter->phydev;
-	phydev->advertising = ecmd->advertising;
-	phydev->autoneg = ecmd->autoneg;
-	phydev->speed = ethtool_cmd_speed(ecmd);
-	phydev->duplex = ecmd->duplex;
+	linkmode_copy(phydev->advertising, cmd->link_modes.advertising);
+	linkmode_copy(phydev->supported, cmd->link_modes.supported);
+	phydev->autoneg = cmd->base.autoneg;
+	phydev->speed = cmd->base.speed;
+	phydev->duplex = cmd->base.duplex;
 
 	genphy_config_aneg(phydev);
 	mutex_unlock(&adapter->poll_mutex);
@@ -419,8 +428,8 @@ static const struct ethtool_ops edma_ethtool_ops = {
 	.get_msglevel = &edma_get_msglevel,
 	.nway_reset = &edma_nway_reset,
 	.get_wol = &edma_get_wol,
-	.get_settings = &edma_get_settings,
-	.set_settings = &edma_set_settings,
+	.get_link_ksettings = &edma_get_settings,
+	.set_link_ksettings = &edma_set_settings,
 	.get_strings = &edma_get_strings,
 	.get_sset_count = &edma_get_strset_count,
 	.get_ethtool_stats = &edma_get_ethtool_stats,
